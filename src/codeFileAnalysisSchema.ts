import { z } from "zod";

// --- Reusable Schemas ---

/** Zod schema for common code elements like functions, methods, or properties. */
const CodeElementSchema = z.object({
    name: z.string().describe("The name of the function, method, or property."),
    signature: z.string().optional().describe("The full signature or declaration line."),
    summary: z.string().optional().describe("A concise LLM-generated summary of what this element does."),
    isAsync: z.boolean().optional().describe("True if the function/method is declared as async."),
    // Future enhancement: Consider adding parameters, return type if consistently extractable and useful.
}).describe("Represents a function, method, or potentially property within the code.");

// --- Structure Schemas ---

/** Zod schema representing a class definition extracted from the code. */
const ClassSchema = z.object({
    name: z.string().describe("The name of the class."),
    signature: z.string().optional().describe("The class declaration line, including generics if applicable."),
    summary: z.string().optional().describe("A concise LLM-generated summary of the class's purpose and responsibility."),
    superClass: z.string().nullable().optional().describe("The name of the direct base class it inherits from, if any."),
    implementedInterfaces: z.array(z.string()).optional().describe("List of interface names implemented by this class."),
    methods: z.array(CodeElementSchema).optional().describe("List of methods defined within this class."),
    properties: z.array(CodeElementSchema).optional().describe("List of properties or fields defined within this class (name only might suffice)."),
    isAbstract: z.boolean().optional().describe("True if the class is declared as abstract (C#/TS)."),
    // Optional: Decorators can be noisy but sometimes useful.
    // decorators: z.array(z.string()).optional().describe("List of decorators/attributes applied to the class."),
}).describe("Represents a class definition.");

/** Zod schema representing an interface definition (primarily for TypeScript/C#). */
const InterfaceSchema = z.object({
    name: z.string().describe("The name of the interface."),
    signature: z.string().optional().describe("The interface declaration line."),
    summary: z.string().optional().describe("A concise LLM-generated summary of the interface's contract or purpose."),
    extendedInterfaces: z.array(z.string()).optional().describe("List of interface names this interface extends from."),
    methods: z.array(CodeElementSchema).optional().describe("List of method signatures defined within this interface."),
    properties: z.array(CodeElementSchema).optional().describe("List of properties defined within this interface."),
}).describe("Represents an interface definition.");

// --- Main Analysis Schema ---

/**
 * Zod schema defining the structure of the JSON object expected
 * from the LLM code analysis. Used for validation and type inference.
 */
export const CodeFileAnalysisSchema = z.object({
    /** The relative path of the analyzed file within the repository. */
    source: z.string().describe("The relative path of the file within the repository."),
    /** A high-level summary generated by the LLM. */
    summary: z.string().describe("A concise LLM-generated summary of the file's overall purpose, functionality, and key exports/components."),
    /** Keywords or tags identified by the LLM. */
    tags: z.array(z.string()).optional().describe("Relevant keywords, concepts, patterns, or frameworks identified in the file (e.g., 'React Component', 'API Client', 'Data Model', 'Strategy Pattern', 'Express Middleware')."),

    /** Detailed structural elements extracted from the code. */
    structure: z.object({
        /** List of imported modules, files, or namespaces. */
        imports: z.array(z.string()).optional().describe("List of imported modules, files, or namespaces."),
        /** List of explicitly exported symbols (JS/TS). */
        // Note: Export extraction might be harder for C# unless focusing on public top-level types.
        exports: z.array(z.string()).optional().describe("List of explicitly exported symbols (functions, classes, variables) if applicable (JS/TS)."),

        // Top-level elements (defined outside classes/interfaces)
        /** List of top-level functions defined in the file. */
        functions: z.array(CodeElementSchema).optional().describe("List of top-level functions defined in the file."),
        /** Key top-level variables or constants declared (simplified representation). */
        variables: z.array(z.object({ name: z.string(), type: z.string().optional() })).optional().describe("Key top-level variables or constants declared."),

        // Main structural components
        /** List of classes defined in the file. */
        classes: z.array(ClassSchema).optional().describe("List of classes defined in the file."),
        /** List of interfaces defined in the file. */
        interfaces: z.array(InterfaceSchema).optional().describe("List of interfaces defined in the file."),
    }).describe("Detailed structural elements extracted from the code."),

    /** Any significant parsing or analysis errors noted by the LLM during extraction. */
    potentialErrors: z.array(z.string()).optional().describe("Any significant parsing or analysis errors encountered by the LLM.")

}).describe("Comprehensive analysis of a source code file for enhancing vector search retrieval.");

/** Inferred TypeScript type from the CodeFileAnalysisSchema. */
export type CodeFileAnalysis = z.infer<typeof CodeFileAnalysisSchema>;